\documentclass[a4paper]{article}

\usepackage{geometry}
\geometry{
	a4paper,
	total={170mm,257mm},
	left=20mm,
	top=20mm,
}

\usepackage{parskip} %Removes paragraph line indents
\usepackage{tabu}
\usepackage{microtype}
\usepackage{booktabs,array}


\makeatletter
\newcolumntype{V}[1]{>{\topsep=0pt\@minipagetrue}p{#1}<{\vspace{-\baselineskip}}}
\makeatother
\newcommand{\command}[1]{\texttt{\string#1}}


\setlength{\parindent}{0pt} % just for the example

%opening
\title{Group Assignment\\ \ \\Compilers\\ \ \\}
\author{Oliver Mikkel Winther Cristensen (klw741) \\ \ \\Mathias BrÃ¸ndum Leroul (swn848)\\ \ \\Sebastian O. Jensen (gjx653)\\ \ \\}
\date{Turn-in date: 20-12-2015}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}
	We have been given the grand task of creating a small compiler, using the high level languages Fasto and SML as well as the low level machine language MIPS. Throughout this paper, we will document every code addition we make and if nothing is stated about the success of the code, it means that the code returns the expected output.
	
\section{Implementation}
	Each implementation step is presented in the same order as the compiler structure: Lexer $\rightarrow$ Parser $\rightarrow$ Type Checker $\rightarrow$ Interpreter $\vee$ MIPS Code Generator
\subsection{Task 1}
	Task 1 is the implementation of True/False, multiplication/division, AND/OR and finally Not/Negation. This task was probably the longest to do, because of the many different components, as well as the fact that we had to learn the rhythm of the coding process.
	
\subsubsection{True and False}

	To begin with, we're given the sub-task to implement the boolean literals True and False. We start out by creating the following test files:
	
\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{bool.fo} &
		\begin{verbatim}
			fun int boolTest(int a) = if a == 1
			then 1 else 0
			
			fun int main() =
			    let a = read(int) in
			    write(boolTest(a))
			  
		\end{verbatim}
		\\
		\command{bool.in} &
		\begin{verbatim}
			1
			
		\end{verbatim}
		\\
		\command{bool.out} &
		\begin{verbatim}
			1
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Starting at the top of the compiler structure, the lexer is upgraded with the proper true and false keywords

\begin{center}	
	\begin{tabular}{lV{322pt}}
		\toprule
		& \verb|Lexer.lex|\\
		\midrule
		&
		\begin{verbatim}
			| "true"  => Parser.TRUE  pos
			| "false" => Parser.FALSE pos
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Then we implement the True/False token type in our parser as well as add True and False to the expression list.

\begin{center}	
	\begin{tabular}{lV{275pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Parser.grm} &
		\begin{verbatim}
			%token <(int*int)> TRUE FALSE
			
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			| TRUE           { Constant (BoolVal true,  $1)}
			| FALSE          { Constant (BoolVal false, $1)}
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

And finally we add the boolean constants to our MIPS code generator.

\begin{center}	
	\begin{tabular}{lV{325pt}}
		\toprule
		& \verb|CodeGen.sml|\\
		\midrule
		&
		\begin{verbatim}
			| Constant (BoolVal b, pos) => 
			    if b then
			        [ Mips.LI (place, makeConst 1) ] 
			    else
			        [ Mips.LI (place, makeConst 0) ]
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

\subsubsection{Multiplication and Division}
Moving on to the implementation of multiplication and division, we again start out with creating test files for each of the two operators.

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Mult.fo} &
		\begin{verbatim}
			fun int Mult(int a) = a * 2
			
			fun int main() =
			    let a = read(int) in
			    write(Mult(a))
		
		\end{verbatim}
		\\
		\command{Mult.in} &
		\begin{verbatim}
			4
		
		\end{verbatim}
		\\
		\command{Mult.out} &
		\begin{verbatim}
			8
			
		\end{verbatim}
		\\
		\command{Div.fo} &
		\begin{verbatim}
			fun int Div(int a) = a / 2
			
			fun int main() =
			    let a = read(int) in
			    write(Div(a))
			
		\end{verbatim}
		\\
		\command{Div.in} &
		\begin{verbatim}
			128
		
		\end{verbatim}
		\\
		\command{Div.out} &
		\begin{verbatim}
			64
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

After creating the test files, we swiftly move on to adding multiplication and division to the lexer.

\begin{center}	
	\begin{tabular}{lV{322pt}}
		\toprule
		& \verb|Lexer.lex|\\
		\midrule
		&
		\begin{verbatim}
			| `*`  { Parser.TIMES  (getPos lexbuf) }
			| `/`  { Parser.DIVIDE (getPos lexbuf) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

In the parser, we add TIMES and DIVIDE to the already created "PLUS MINUS DEQ EQ LTH" token type. They're given a proper precedence order, as well as added to the expression list.

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Parser.grm} &
		\begin{verbatim}
			%token <(int*int)> PLUS MINUS DEQ EQ LTH DIVIDE TIMES
		
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			%left DIVIDE
			%left TIMES
		
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			| Exp DIVIDE Exp { Divide ($1, $3, $2) }
			| Exp TIMES Exp  { Times  ($1, $3, $2) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Moving on to the type checker, we make sure that we can properly check the used types, when doing multiplication and division, adding the cases to the \verb|checkExp| function.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|TypeChecker.sml|\\
		\midrule
		&
		\begin{verbatim}
		    | In.Times (e1, e2, pos)
		      => let val (_, e1_dec, e2_dec) =
			             checkBinOp ftab vtab (pos, Int, e1, e2)
		         in (Int,
		             Out.Times (e1_dec, e2_dec, pos))
		         end
		 
		    | In.Divide (e1, e2, pos)
		      => let val (_, e1_dec, e2_dec) =
		                 checkBinOp ftab vtab (pos, Int, e1, e2)
		         in (Int,
		             Out.Divide (e1_dec, e2_dec, pos))
		         end		
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

We go ahead and implement them in our interpreter, extending \verb|evalExp| function with the proper cases.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|Interpreter.sml|\\
		\midrule
		&
		\begin{verbatim}
			| evalExp ( Times(e1, e2, pos), vtab, ftab ) =
			      let val res1   = evalExp(e1, vtab, ftab)
			          val res2   = evalExp(e2, vtab, ftab)
			      in  case (res1, res2) of
			              (IntVal n1, IntVal n2) => IntVal (n1*n2)
			            | _ => invalidOperands
			                   "Multiplication on non-integral args: " 
			                   [(Int, Int)] res1 res2 pos
			      end
			  
			| evalExp ( Divide(e1, e2, pos), vtab, ftab ) =
			      let val res1   = evalExp(e1, vtab, ftab)
			          val res2   = evalExp(e2, vtab, ftab)
			      in  case (res1, res2) of
			              (IntVal n1, IntVal n2) => IntVal (n1 div n2)
			            | _ => invalidOperands
			                   "Division on non-integral args: " 
			                   [(Int, Int)] res1 res2 pos
			      end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Finally, cases for multiplication and division are added to the \verb|compileExp| function in the MIPS code generator.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|CodeGen.sml|\\
		\midrule
		&
		\begin{verbatim}
			| Divide (e1, e2, pos) =>
			    let val t1 = newName "divide_L"
			        val t2 = newName "divide_R"
			        val code1 = compileExp e1 vtable t1
			        val code2 = compileExp e2 vtable t2
			    in code1 @ code2 @ [Mips.DIV (place,t1,t2)]
			    end
			| Times (e1, e2, pos) =>
			    let val t1 = newName "times_L"
			        val t2 = newName "times_R"
			        val code1 = compileExp e1 vtable t1
			        val code2 = compileExp e2 vtable t2
			    in code1 @ code2 @ [Mips.MUL (place,t1,t2)]
			    end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

\subsubsection{AND and OR}
For the AND and OR implementations, we add them as short-curc
Moving on to the implementation of the boolean operators, AND and OR, we again start out with creating test files for each of them.\\

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{and.fo} &
		\begin{verbatim}
			fun bool FAnd(bool a, bool b) = a && b
			
			fun bool main() =
			    let a = read(bool) in
			    let b = read(bool) in
			    let c = write(FAnd(a,a)) in
			    let d = write(FAnd(b,b)) in
			    let e = write(FAnd(a,b)) in
			    write(FAnd(b,a))
		
		\end{verbatim}
		\\
		\command{and.in} &
		\begin{verbatim}
		1
		0
		
		\end{verbatim}
		\\
		\command{and.out} &
		\begin{verbatim}
		truefalsefalsefalse
		
		\end{verbatim}
		\\
		\command{or.fo} &
		\begin{verbatim}
			fun bool orTest(bool a, bool b) = a || b
			
			fun bool main() =
			    let a = read(bool) in
			    let b = read(bool) in
			    let c = write(orTest(b,b)) in
			    let d = write(orTest(a,a)) in
			    let e = write(orTest(a,b)) in
			    write(orTest(b,a))
		
		\end{verbatim}
		\\
		\command{or.in} &
		\begin{verbatim}
		1
		0
		
		\end{verbatim}
		\\
		\command{or.out} &
		\begin{verbatim}
		falsetruetruetrue
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

With the test files in place, we can move on to the lexer.

\begin{center}	
	\begin{tabular}{lV{322pt}}
		\toprule
		& \verb|Lexer.lex|\\
		\midrule
		&
		\begin{verbatim}
			| "&&"  { Parser.AND  (getPos lexbuf) }
			| "||"  { Parser.OR   (getPos lexbuf) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

In the parser, we add AND and OR to the "TRUE FALSE" token type as well as add them to the expression list.

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Parser.grm} &
		\begin{verbatim}
		%token <(int*int)> TRUE FALSE AND OR
				
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			| Exp AND Exp { And ($1, $3, $2) }
			| Exp OR  Exp { Or  ($1, $3, $2) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Moving on to the type checker, we make sure that we can properly check the used types, when using AND and OR.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|TypeChecker.sml|\\
		\midrule
		&
		\begin{verbatim}
			| In.And (e1, e2, pos)
			  => let val (t1, e1') = checkExp ftab vtab e1
			         val (t2, e2') = checkExp ftab vtab e2
			     in case (t1 = t2, t1) of
			             (false, _) => raise Error
			                           ("And cannot take "^ ppType t1 ^
			                            "and "^ppType t2, pos)
			           | (true, Array _) => 
			             raise Error ("And cannot oporate on arrays", pos)
			           | _ => (Bool, Out.And (e1', e2', pos))
			    end
			| In.Or (e1, e2, pos)
			  => let val (t1, e1') = checkExp ftab vtab e1
			         val (t2, e2') = checkExp ftab vtab e2
			     in case (t1 = t2, t1) of
			             (false, _) => raise Error 
			                           ("Or cannot take "^ ppType t1 ^
			                            "and "^ppType t2, pos)
			           | (true, Array _) => 
			             raise Error ("Or cannot operate on arrays", pos)
			           | _ => (Bool, Out.Or (e1', e2', pos))
			     end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

We go ahead and implement them in our interpreter.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|Interpreter.sml|\\
		\midrule
		&
		\begin{verbatim}
			| evalExp (And (e1, e2, pos), vtab, ftab) =
			      let val res1 = evalExp(e1, vtab, ftab)
			      in  case res1 of
			            (BoolVal true) => evalExp(e2, vtab, ftab)
			          | (BoolVal false) => BoolVal false
			          | _ => raise Fail "Arguments to AND is not of type bool"
			      end
			  
			| evalExp (Or (e1, e2, pos), vtab, ftab) =
			      let val res1 = evalExp(e1, vtab, ftab)
			      in  case res1 of
			            (BoolVal false) => evalExp(e2, vtab, ftab)
			          | (BoolVal true)  => BoolVal true
			          | _ => raise Fail "Arguments to AND is not of type bool"
			      end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Finally we add the AND and OR to the MIPS code generator.

\begin{center}	
	\begin{tabular}{lV{325pt}}
		\toprule
		& \verb|CodeGen.sml|\\
		\midrule
		&
		\begin{verbatim}
			| And (e1, e2, pos) =>
			  let val t1 = newName "and_L"
			      val t2 = newName "and_R"
			      val code1 = compileExp e1 vtable t1
			      val code2 = compileExp e2 vtable t2
			      val finish = newName "finish"
			  in  code1 @
			      [ Mips.LI (place,"0")
			      , Mips.BEQ (t1, "0", finish) ] @
			      code2 @
			      [ Mips.BEQ (t2, "0", finish)
			      , Mips.LI (place, "1")
			      , Mips.LABEL finish ]
			  end
			
			| Or (e1, e2, pos) =>
			  let val t1 = newName "or_L"
			      val t2 = newName "or_R"
			      val code1 = compileExp e1 vtable t1
			      val code2 = compileExp e2 vtable t2
			      val finish = newName "finish"
			  in  code1 @
			      [ Mips.LI (place,"1")
			      , Mips.BNE (t1, "0", finish) ] @
			      code2 @
			      [ Mips.BNE (t2, "0", finish)
			      , Mips.LI (place, "0")
			      , Mips.LABEL finish ]
			  end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

\subsubsection{Not and Negation}
Lastly for this task, we will implement Not and Negation. We made test files for Not, but for Negate, these are already given to us. When run, the tests are passed.\\

\begin{center}	
	\begin{tabular}{lV{275pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{not.fo} &
		\begin{verbatim}
			fun bool notFun(bool t) = not t
			
			fun bool main() =
			    let a = read(bool) in
			    let b = read(bool) in
			    let c = write(notFun(a)) in
			    write(notFun(b))
		
		\end{verbatim}
		\\
		\command{not.in} &
		\begin{verbatim}
			1
			0
		
		\end{verbatim}
		\\
		\command{not.out} &
		\begin{verbatim}
			falsetrue
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

After creating the test files, we move on to the lexer

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Lexer.lex} &
		\begin{verbatim}
			| "not" => Parser.NOT pos
			
		\end{verbatim}
		\\
		\command{Lexer.lex} &
		\begin{verbatim}
			| `~` { Parser.NEGATE (getPos lexbuf) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

In the parser, we add Not and Negate to the "TRUE FALSE AND OR" token type. We make them non-associative. And lastly, we add the two expressions to the expression list.

\begin{center}	
	\begin{tabular}{lV{280pt}}
		\toprule
		File name & Code\\
		\midrule
		\command{Parser.grm} &
		\begin{verbatim}
			%token <(int*int)> TRUE FALSE AND OR NOT NEGATE
		
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			%nonassoc NOT
			%nonassoc NEGATE
		
		\end{verbatim}
		\\
		\command{Parser.grm} &
		\begin{verbatim}
			| NOT Exp    { NOT    ($2, $1) }
			| NEGATE Exp { NEGATE ($2, $1) }
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Moving on to the type checker, we make sure that we can properly check the used types, when using Not and Negate.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|TypeChecker.sml|\\
		\midrule
		&
		\begin{verbatim}
			| In.Not (e, pos)
			  => let val (t1, e') = checkExp ftab vtab e
			     in  case (t1) of
			           (Bool) => (Bool, Out.Not (e', pos))
			         | _ => raise Error ("Invalid Argument type", pos)
			     end
			
			| In.Negate (e, pos)
			  => let val (t1, e') = checkExp ftab vtab e
			     in  case (t1) of
			           (Int) => (Int, Out.Negate (e', pos))
			         | _ => raise Error ("Invalid Argument type", pos)
			     end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

We go ahead and implement them in our interpreter.

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|Interpreter.sml|\\
		\midrule
		&
		\begin{verbatim}
			| evalExp ( Not(e, pos), vtab, ftab ) =
			      let val res = evalExp(e, vtab, ftab)
			      in  case (res) of
			            (BoolVal n) => BoolVal (if n then false else true)
			          | _ => invalidOperand "NOT on non-boolean args: " 
			                 Bool res pos
			      end
			
			| evalExp ( Negate(e, pos), vtab, ftab ) =
			      let val res = evalExp(e, vtab, ftab)
			      in  case (res) of
			            (IntVal n) => IntVal (n * (~1))
			          | _ => invalidOperand "Negate on non-integer args: " 
			                 Int res pos
			      end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

Finally we add the expressions to the MIPS code generator

\begin{center}	
	\begin{tabular}{lV{330pt}}
		\toprule
		& \verb|CodeGen.sml|\\
		\midrule
		&
		\begin{verbatim}
			| Not (e', pos) =>
			      let val t1 = newName "bool"
			          val code = compileExp e' vtable t1
			      in  code @ 
			          [Mips.XORI (place, t1, "1")]
			      end
			
			
			| Negate (e', pos) =>
			         let val t1 = newName "negate"
			             val code = compileExp e' vtable t1
			         in  code @ [Mips.SUB (place, "0", t1)]
			         end
		\end{verbatim}
		\\
		\bottomrule \\
	\end{tabular}
\end{center}

\subsection{Task 2}
	This task consists of the compiler implementation of \verb|iota|, \verb|map| and \verb|reduce|. \verb|iota| was quite straight forward, as the hints in task 2 quides you through the whole thing; step-by-step. So we will skip explaining the implementation of \verb|iota| and go straight to map and reduce.

\subsubsection{map}
	Just like in task one, we need to extend the lexer, parser, type checker, interpreter and the code generator to accept the map operator.
	
	(INSERT MAP TESTS HERE)
	
	After creating the test files, we can begin with the top of the compiler structure, which is the lexter.
	
	\begin{center}	
		\begin{tabular}{lV{322pt}}
			\toprule
			& \verb|Lexer.lex|\\
			\midrule
			&
			\begin{verbatim}
				| "map" => Parser.MAP pos
			\end{verbatim}
			\\
			\bottomrule \\
		\end{tabular}
	\end{center}
	
	In the parser, we add MAP to the previously created "IOTA" token type and to the expression list as well.
	
	\begin{center}	
		\begin{tabular}{lV{280pt}}
			\toprule
			File name & Code\\
			\midrule
			\command{Parser.grm} &
			\begin{verbatim}
			%token <(int*int)> IOTA MAP
			
			\end{verbatim}
			\\
			\command{Parser.grm} &
			\begin{verbatim}
				| MAP LPAR FunArg COMMA Exp RPAR
				      { Map ($3, $5, (), (), $1) }
			\end{verbatim}
			\\
			\bottomrule \\
		\end{tabular}
	\end{center}
	
	Moving on to the type checker, we make sure that we can properly check the types that the Map function uses, extending the \verb|checkExp| function with the proper cases.
	
	\begin{center}	
		\begin{tabular}{lV{330pt}}
			\toprule
			& \verb|TypeChecker.sml|\\
			\midrule
			&
			\begin{verbatim}
				| In.Map (f, arr_exp, _, _, pos)
				  => let val (fnew, f_returntp, f_argument) =
				             checkFunArg(f, vtab, ftab, pos)
				         val arr_exp_tp = checkExp ftab vtab arr_exp
				         val arr_eltp = case arr_eltp of
				                          Array t => t
				                        | _ => Error ("Map: wrong type of 
				                                       array exp")
				         val f_argtp  = case f_argument of
				                          [tp] => tp
				                        | _ => Error ("Map Wrong argument 
				                                       fn type ")
				         in if arr_eltp = f_argtp
				            then (Array f_returntp, 
				                        Out.Map (fnew, arr_exp_tp, f_argument, 
				                                 f_returntp, pos))
				            else raise Error ("Map: wrong argument type " ^
				                              ppType e_type, pos)
				         end
			\end{verbatim}
			\\
			\bottomrule \\
		\end{tabular}
	\end{center}
	
	Next stop is the interpreter, where we extend the \verb|evalExp| function to be able to interpret the \verb|map| function.
	
	\begin{center}	
		\begin{tabular}{lV{330pt}}
			\toprule
			& \verb|Interpreter.sml|\\
			\midrule
			&
			\begin{verbatim}
				| evalExp ( Map (farg, arrexp, _, _, pos), vtab, ftab ) = 
				      let val ls = evalExp(arrexp, vtab,ftab)
				      in
				          map (fn x => let val (result, tp) =
				                                evalFunArg(farg, vtab, ftab, 
				                                pos, x)
				                       in result end ) 
				          ls
				      end
			\end{verbatim}
			\\
			\bottomrule \\
		\end{tabular}
	\end{center}
	
	Finally the \verb|compileExp| function in the MIPS code generator can be extended with the \verb|map| function.
	
	\begin{center}	
		\begin{tabular}{lV{330pt}}
			\toprule
			& \verb|CodeGen.sml|\\
			\midrule
			&
			\begin{verbatim}
				  | Map (farg, arg_exp, elem_type, ret_type, pos) => 
				        let
				            val res_reg = newName()
				            val elem_reg = 
				        in
				            body
				        end
				        
				        val loop_map0 = case getElemSize elemType of
				                          One => Mips.LB (res_reg, elem_reg, "0") 
				                          :: applyfunArg (farg, [res_reg], vtable,
				                                          res_reg, pos) @ 
				                          [Mips.Addi(elem_reg, elem_reg, "1")]
				                        | Four => Mips.LW (res_reg, elem_reg, "0")
				                          :: applyfunArg (farg, [res_reg], vtable,
				                                          res_reg, pos) @ 
				                          [Mips.Addi(elem_reg, elem_reg, "4")]
			\end{verbatim}
			\\
			\bottomrule \\
		\end{tabular}
	\end{center}
	
\subsubsection{reduce}

\subsection{Task 3}

\section{Results}
\section{Conclusion}

\end{document}
